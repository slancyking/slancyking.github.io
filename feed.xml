<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>No one has ever become poor by giving</title>
    <link href="https://slancyking.github.io/feed.xml" rel="self" />
    <link href="https://slancyking.github.io" />
    <updated>2024-04-04T01:03:15+08:00</updated>
    <author>
        <name>slancyking</name>
    </author>
    <id>https://slancyking.github.io</id>

    <entry>
        <title>一款扑克牌游戏分析</title>
        <author>
            <name>slancyking</name>
        </author>
        <link href="https://slancyking.github.io/yi-kuan-bu-ke-pai-you-xi-fen-xi/"/>
        <id>https://slancyking.github.io/yi-kuan-bu-ke-pai-you-xi-fen-xi/</id>

        <updated>2024-04-04T01:03:15+08:00</updated>
            <summary>
                <![CDATA[
                    背景介绍 有一天，我的一个朋友提到，“这个扑克牌项目可以赚钱。这是一款网页游戏，以斗牛和金花等流行游戏为特色。游戏是通过移除两张小丑牌来进行的，最多允许 12 名玩家在一张桌子上竞争。每个玩家有4张牌，游戏的目标是比较手牌的大小。一个房间可以进行 24 轮比赛。一般的游戏玩法包括查看前三张牌，然后决定是否竞标庄家位置以及下注多少，然后查看第四张牌并决定丢弃哪一张。最后，根据手的大小计算分数。我们的策略包括在牌桌上占据多个位置，以创造数量优势。了解了我们的牌，我们可以粗略地计算出第四张牌的概率和预期分数。竞标我们预期手值最高的经销商是我们盈利的核心策略。 One day, a friend of mine mentioned, “There’s money to be made in this poker card project.” It’s a web game featuring popular games like Bullfight and Golden Flower. The game is played by removing the two joker cards,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h1 id="背景介绍">背景介绍</h1>
<p>有一天，我的一个朋友提到，“这个扑克牌项目可以赚钱。这是一款网页游戏，以斗牛和金花等流行游戏为特色。游戏是通过移除两张小丑牌来进行的，最多允许 12 名玩家在一张桌子上竞争。每个玩家有4张牌，游戏的目标是比较手牌的大小。一个房间可以进行 24 轮比赛。一般的游戏玩法包括查看前三张牌，然后决定是否竞标庄家位置以及下注多少，然后查看第四张牌并决定丢弃哪一张。最后，根据手的大小计算分数。我们的策略包括在牌桌上占据多个位置，以创造数量优势。了解了我们的牌，我们可以粗略地计算出第四张牌的概率和预期分数。竞标我们预期手值最高的经销商是我们盈利的核心策略。</p>
<h1 id="background-introduction">Background Introduction</h1>
<p>One day, a friend of mine mentioned, “There’s money to be made in this poker card project.” It’s a web game featuring popular games like Bullfight and Golden Flower. The game is played by removing the two joker cards, allowing up to 12 players to compete at a single table. Each player is dealt 4 cards, and the game’s objective is to compare the size of the hands. A room hosts 24 rounds of play. The general gameplay involves looking at the first three cards, then deciding whether to bid for the dealer position and how much to bet, followed by viewing the fourth card and deciding which one to discard. Finally, points are tallied based on the size of the hand. Our strategy involves occupying several positions at the table to create a numerical advantage. Knowing our cards, we can roughly calculate the probability of the fourth card and the expected score. Bidding for the dealer with our highest expected hand value is our core strategy for profit.</p>
<h1 id="可行性分析">可行性分析</h1>
<h6 id="1通讯部分">1.通讯部分</h6>
<p>首先，我们观察到该网站的结构非常简单，JavaScript代码中没有加密或保护。数据使用 Protobuf 进行结构化，通信通过 WebSocket 进行处理。因此，我们下载了特定的前端代码，用于构建登录过程和游戏的通信过程。</p>
<h6 id="2收集有用数据">2.收集有用数据</h6>
<p>我们注意到，在游戏结束后，房间会显示比分摘要和游戏过程的记录。除了需要房间 ID 和登录之外，可以不受任何限制地访问这些游戏记录。从数据安全的角度来看，理想情况下，只有参与游戏的玩家或联盟管理员才有权访问。这些信息非常有价值;例如，我们可以构建不同的房间 ID 来访问各个房间的游戏过程。我们的目标是分析卡片组合的频率，以确定是否存在“卡片工厂”模式，或者某些卡片是否更频繁地出现。此外，我们不确定是否有机器人在玩游戏。如果是这样，避免它们将是有益的。有关游戏过程的统计数据可以帮助我们识别长时间玩游戏的玩家或始终在一起玩的玩家，这些是我们打算避免的群体。</p>
<h1 id="feasibility-analysis">Feasibility Analysis</h1>
<h6 id="1communication-analysis">1.Communication Analysis</h6>
<p>Firstly, we observed that the website’s structure is quite straightforward, with no encryption or protection in the JavaScript code. Data is structured using Protobuf, and communication is handled through WebSockets. Therefore, we downloaded the specific frontend code for our use in constructing both the login process and the game’s communication process.</p>
<h6 id="2data-collection">2.Data Collection</h6>
<p>We noticed that after a game concludes, the room displays a score summary and records of the game process. These game records are accessible without any restrictions beyond needing a room ID and being logged in. From a data security perspective, ideally, only players who participated in the game or alliance administrators should have access. This information is highly valuable; for instance, we can construct different room IDs to access the gameplay processes of various rooms. Our goal is to analyze the frequency of card combinations to determine if there’s a “card factory” pattern or if certain cards appear more frequently. Additionally, we’re uncertain if there are bots playing the game. If so, avoiding them would be beneficial. Statistics on the game process can help us identify players who play for extended periods or those who consistently play together, which are groups we intend to avoid.</p>
<h1 id="网络通讯分析--network-communication-analysis">网络通讯分析  Network Communication Analysis</h1>
<p>在检查了 JavaScript 源代码后，我插入了函数以在关键通信点打印数据包。这使我们能够了解与游戏过程中的动作相对应的通信内容。
After inspecting the JavaScript source code, I inserted functions to print the data packets at key points of communication. This allows us to understand the content of communications corresponding to actions during gameplay. </p>
<pre><code>send(mid, sid, data) {
      let eventName = ProtocolConfig.getRequestMsgType(mid, sid);
      console.error(&quot;SK Debug SendMsg &quot; , mid , sid ,eventName,data , JSON.stringify(data)) &lt;----
      skipover
      }
      
onSocketMessage: function (message) {
      if (this.getMessagesed === false) {
        this.getMessagesed = true;
      }
      var reader = new FileReader();
      var data = message.data.slice(0);
      reader.readAsArrayBuffer(data);
      reader.onload = function (e) {
        var MIDArray = new Uint32Array(e.currentTarget.result.slice(0, 4));
        var mid = MIDArray[0]; //mid
        var SIDArray = new Uint16Array(e.currentTarget.result.slice(4, 6));
        var sid = SIDArray[0]; //sid
        let eventName = ProtocolConfig.getCallBack(mid, sid);
        console.log(&quot;SK Debug Receive&quot; , mid,sid ,eventName)	&lt;----
        skipover
        }
</code></pre>
<p>对于登录过程，使用 RSA 加密，公钥直接嵌入到 HTML 代码中。我们实施了一个系统，让多个帐户使用代理登录，并记录他们的 cookie 以备将来收集数据。
For the login process, RSA encryption is used, with the public key embedded directly in the HTML code. We implemented a system for multiple accounts to log in using proxies and recorded their cookies for future data collection purposes.</p>
<pre><code>def get_encrypt(data, public_key):
    # 将数据转换为 JSON 格式字符串
    data_str = json.dumps(data)

    # 去除公钥字符串中的格式信息和换行符
    public_key = public_key.replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
    public_key = public_key.replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
    public_key = public_key.replace(&quot;\n&quot;, &quot;&quot;)

    # 将公钥字符串解码为字节对象
    public_key_bytes = base64.b64decode(public_key)

    # 使用 RSA 密钥创建加密器
    rsa_key = RSA.import_key(public_key_bytes)
    cipher = PKCS1_v1_5.new(rsa_key)

    # 对数据进行加密
    encrypted_data = cipher.encrypt(data_str.encode())

    # 将加密后的数据进行 Base64 编码并返回
    encrypted_data_base64 = base64.b64encode(encrypted_data).decode()
    return encrypted_data_base64

# 获取当前脚本所在的目录
current_dir = os.path.dirname(os.path.abspath(__file__))

proxyList = []
account_list = []
cookie_list = []

def getProxy(_idx):
    if _idx &gt;= len(proxyList):
        _idx = _idx % len(proxyList)
    return { &#39;http&#39;: proxyList[_idx]  }
 
 
def get_cookie_and_proxy(cookie_list,current_index_cookie):
    cookieInfo = None
    # proxyInfo = None
    with current_index_cookie.get_lock():
        if current_index_cookie.value &gt;= len(cookie_list):
            current_index_cookie.value = 0
        cookieInfo = cookie_list[current_index_cookie.value]
        # proxyInfo = getProxy(current_index_cookie.value)
        current_index_cookie.value += 1
 
    return cookieInfo #, proxyInfo

public_key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC0rA3V8MUt1cQqG7BAQgZYehiS
p2428HaURVUWxcVdNQRqxYPUBdd8Dm/gv+zK7aHWLosQ/oQtSuwviyTMSZ+Mf7NO
N62Ak3QALa5n6Anku5a6071JPcGtqmx4AHpq6uLX2QRRyFnPH3lAMo92uvMIa3C3
Iv3XcTrXVst51nxRDQIDAQAB
-----END PUBLIC KEY-----
&quot;&quot;&quot;
 
url_base = &#39;http://120.79.94.201/&#39;
login_url = url_base + &#39;Public/login&#39;
baseUrl = url_base + &quot;Jt/fjr/id/&quot;
startRoomId = 1570000
save_data_dir = &quot;&quot;
def pre_login():
    global cookie_list
    for i in range(len(account_list)):
        tmp_acc = account_list[i]
        tmp_proxy = getProxy(i)
        index_response = requests.get(url_base,proxies=tmp_proxy)
        print(index_response)
        # 打印登录后的Cookie
        print(&quot;登录后的Cookie:&quot;, index_response.cookies.get_dict()) 

        encrypted_data = get_encrypt(tmp_acc, public_key)
        print(&quot;加密结果:&quot; ,encrypted_data)

        response = requests.post(login_url,  data = {&#39;data&#39;: encrypted_data}, cookies = index_response.cookies) #, headers=headers

        if response.status_code == 200:
            # 请求成功，可以在这里处理响应数据
            print(response.json())
            if response.json()[&#39;code&#39;] != 1:
                return False
        else:
            # 请求失败，可以在这里处理错误
            print(f&quot;Error: {response.status_code}&quot;)
            return False
    
        cookie_list.append(index_response.cookies)
    return True
</code></pre>
<h1 id="数据收集及测试">数据收集及测试</h1>
<p>使用 BeautifulSoup 将游戏过程网页解析后.整理为更易保存和加载的json格式.
根据这一批json文件  整理了牌型出现频率的统计,用户出现次数统计. 用户组队情况统计. 联盟热度统计.</p>
<p>谨慎起见,还需要一个模拟游戏过程,来大概确定一下这样玩是否可以盈利, 观察了一下其他玩家游戏的过程,我们写了一个模拟的例子来提供参考.</p>
<p>那首先来一个 发扑克牌的 产生的扑克牌由本地随机生成   Poker.py  </p>
<p>根据观察到的游戏逻辑,我们还需要一个计分以及判断牌大小的类 three_plus_one.py
接下来我们要模拟游戏过程  game_3_p_1.py, 这个主要就是自己几个号里面协商好,牌面期望分数最高的号来抢庄,其他号如果符合条件也要抢庄.里面大概会模拟出其他玩家牌面好的情况也会抢庄,以及会有 2%的概率会做出非理智性的抢庄动作,为了简化流程,参与抢庄的玩家如果没有抢到庄家,那么他会使用最高的投注倍率15.非理智性抢庄投注倍率为最低倍率3.
理论上,只要到了5-8个号进入同一个房间,只要自己其中最高期望值的号一直抢庄.那么每一把下来,盈利的概率还是很高的.因为总是这几个号最高期望得分与其他人做比较,其他几个号想赢是困难的. 这是最核心的盈利逻辑</p>
<p>那么接下来就是进行模拟 game_3_p_1.py
得到的结果还不错,感觉是可以做的.那么就使用采集的对局牌型数据来代入这个模型进行模拟.
最后得到的结果是下面这样的  </p>
<pre><code> self_bet_score:5000000 ,max_bet_score:5000000
 有判断模式
2 个自己的号 ================================
总模拟结束, 盈利  3230.38
平均每一场: 13.459916666666667
平均每一场号均: 6.729958333333333
3 个自己的号 ================================
总模拟结束, 盈利  1693.061
平均每一场: 7.054420833333333
平均每一场号均: 2.351473611111111
4 个自己的号 ================================
总模拟结束, 盈利  2039.968
平均每一场: 8.499866666666668
平均每一场号均: 2.124966666666667
5 个自己的号 ================================
总模拟结束, 盈利  5752.276
平均每一场: 23.967816666666668
平均每一场号均: 4.793563333333333
6 个自己的号 ================================
总模拟结束, 盈利  5888.471
平均每一场: 24.535295833333333
平均每一场号均: 4.089215972222222
</code></pre>
<p>感觉效果还不错.接下来使用提取到的历史数据来进行模拟 game_3_p_1_from_data.py</p>
<p>经过几次玩法的修改得到</p>
<pre><code>(&#39;完全模拟结束 ,盈利:&#39;, 727463.296)
(&#39;平均:&#39;, 19.0715)
</code></pre>
<p>按照预想的利润还是不错的.</p>
<p>那么接下来就是需要有一个可以动态收集这些数据的服务,例如我需要有一个脚本动态收集组队用户数据.
那么就需要及时的获取到最新的数据. 所以写了个webAPI.py  让执行脚本时,在需要的时候可以去调用它</p>
<p>我们用flask去写.大概结构是这样的  webAPI.py</p>
<pre><code>def authenticate_password():
    pass
    # 校验密码，如果不正确，中断请求
    
@app.route(&quot;/reloadConfig&quot;, methods=[&#39;POST&#39;])
def reloadConfig():
    &#39;&#39;&#39;重新载入配置&#39;&#39;&#39;
    pass

@app.route(&quot;/calcGroupUser&quot;, methods=[&#39;POST&#39;])
def calcGroupUser():
    &#39;&#39;&#39;计算组队用户&#39;&#39;&#39;
    pass
    
def work_backGround(runConfig:RunConfig):
    &#39;&#39;&#39;更新数据的线程,大概间隔10分钟获取一次&#39;&#39;&#39;
    pass
</code></pre>
<p>当时还遇到一个问题,谁和谁一起组队的话,我是使用下划线将用户之间的id连接起来作为键 类似  10227633_33929156_23393233
当大量的组合需要统计的时候,内存使用的特别快. 因为相对的id组合可能大概百亿级别
所有我将数字转换成其他的符号,使键变成了 类似  dæ2_úH§_ÐÑg 这样的文本, 这样内存的使用会小很多.如果是还有更加苛刻的内存要求. 那就只能将这些键储存在硬盘中,并给他一个 number编号, 再将编号转换成 类似 dæ2的 键, 以cpu资源和硬盘空间去换取内存空间的使用率</p>
<pre><code>SYMBOLS = &quot;!\&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^`abcdefghijklmnopqrstuvwxyz{|}~¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀ&quot;
SPLITESYM = &quot;_&quot;

def decimal_to_custom_base(decimal_number):
    if decimal_number == 0:
        return SYMBOLS[0]

    result = &quot;&quot;
    while decimal_number &gt; 0:
        remainder = decimal_number % len(SYMBOLS)
        result = SYMBOLS[remainder] + result
        decimal_number //= len(SYMBOLS)

    return result

def custom_base_to_decimal(custom_base_string):
    decimal_number = 0
    base = len(SYMBOLS)

    for char in custom_base_string:
        decimal_number = decimal_number * base + SYMBOLS.index(char)

    return decimal_number
</code></pre>
<p>详细的实现逻辑可以在我的  <a href="https://github.com/slancyking/threeInOne_Analyze">源代码</a> 中找到。</p>

            ]]>
        </content>
    </entry>
</feed>
